# Prework Readings 






## How To Think Like A Programmer

Essentially, it’s all about a more effective way for problem solving.

  1. Understand
      Know exactly what is being asked. Most hard problems are hard because you don’t understand them (hence why this is the first step).

      How to know when you understand a problem? When you can explain it in plain English.

      Do you remember being stuck on a problem, you start explaining it, and you instantly see holes in the logic you didn’t see before?

      Most programmers know this feeling.

      This is why you should write down your problem, doodle a diagram, or tell someone else about it (or thing… some people use a rubber duck).

  2. Plan
      Don’t dive right into solving without a plan (and somehow hope you can muddle your way through). Plan your solution!

      Nothing can help you if you can’t write down the exact steps.

      In programming, this means don’t start hacking straight away. Give your brain time to analyze the problem and process the information.

      To get a good plan, answer this question:

      “Given input X, what are the steps necessary to return output Y?”

      Sidenote: Programmers have a great tool to help them with this… Comments!


  3. Divide
      Pay attention. This is the most important step of all.

      Do not try to solve one big problem. You will cry.

      Instead, break it into sub-problems. These sub-problems are much easier to solve.

      Then, solve each sub-problem one by one. Begin with the simplest. Simplest means you know the answer (or are closer to that answer).

      After that, simplest means this sub-problem being solved doesn’t depend on others being solved.

      Once you solved every sub-problem, connect the dots.

      Connecting all your “sub-solutions” will give you the solution to the original problem. Congratulations!

      This technique is a cornerstone of problem-solving. Remember it (read this step again, if you must).

      “If I could teach every beginning programmer one problem-solving skill, it would be the ‘reduce the problem technique.’
      For example, suppose you’re a new programmer and you’re asked to write a program that reads ten numbers and figures out which number is the third highest. For a brand-new programmer, that can be a tough assignment, even though it only requires basic programming syntax.
      If you’re stuck, you should reduce the problem to something simpler. Instead of the third-highest number, what about finding the highest overall? Still too tough? What about finding the largest of just three numbers? Or the larger of two?
      Reduce the problem to the point where you know how to solve it and write the solution. Then expand the problem slightly and rewrite the solution to match, and keep going until you are back where you started.” — V. Anton Spraul


      4. Stuck?
          By now, you’re probably sitting there thinking “Hey Richard... That’s cool and all, but what if I’m stuck and can’t even solve a sub-problem??”

          First off, take a deep breath. Second, that’s fair.

          Don’t worry though, friend. This happens to everyone!

          The difference is the best programmers/problem-solvers are more curious about bugs/errors than irritated.

          In fact, here are three things to try when facing a whammy:

          Debug: Go step by step through your solution trying to find where you went wrong. Programmers call this debugging (in fact, this is all a debugger does).
          “The art of debugging is figuring out what you really told your program to do rather than what you thought you told it to do.”” — Andrew Singer
          Reassess: Take a step back. Look at the problem from another perspective. Is there anything that can be abstracted to a more general approach?
          “Sometimes we get so lost in the details of a problem that we overlook general principles that would solve the problem at a more general level. […]
          The classic example of this, of course, is the summation of a long list of consecutive integers, 1 + 2 + 3 + … + n, which a very young Gauss quickly recognized was simply n(n+1)/2, thus avoiding the effort of having to do the addition.” — C. Jordan Ball
          Sidenote: Another way of reassessing is starting anew. Delete everything and begin again with fresh eyes. I’m serious. You’ll be dumbfounded at how effective this is.

          Research: Ahh, good ol’ Google. You read that right. No matter what problem you have, someone has probably solved it. Find that person/ solution. In fact, do this even if you solved the problem! (You can learn a lot from other people’s solutions).
          Caveat: Don’t look for a solution to the big problem. Only look for solutions to sub-problems. Why? Because unless you struggle (even a little bit), you won’t learn anything. If you don’t learn anything, you wasted your time.



          Practice
              Don’t expect to be great after just one week. If you want to be a good problem-solver, solve a lot of problems!

              Practice. Practice. Practice. It’ll only be a matter of time before you recognize that “this problem could easily be solved with <insert concept here>.”

              How to practice? There are options out the wazoo!

              Chess puzzles, math problems, Sudoku, Go, Monopoly, video-games, cryptokitties, bla… bla… bla….

              In fact, a common pattern amongst successful people is their habit of practicing “micro problem-solving.” For example, Peter Thiel plays chess, and Elon Musk plays video-games.

              “Byron Reeves said ‘If you want to see what business leadership may look like in three to five years, look at what’s happening in online games.’
              Fast-forward to today. Elon [Musk], Reid [Hoffman], Mark Zuckerberg and many others say that games have been foundational to their success in building their companies.” — Mary Meeker (2017 internet trends report)
              Does this mean you should just play video-games? Not at all.

              But what are video-games all about? That’s right, problem-solving!

              So, what you should do is find an outlet to practice. Something that allows you to solve many micro-problems (ideally, something you enjoy).

              For example, I enjoy coding challenges. Every day, I try to solve at least one challenge (usually on Coderbyte).

              Like I said, all problems share similar patterns.

      My Synopsis: In order to be a good programmer you need to be a good planner. The idea is to understand the problems as oppose to the syntax. I originally thought you should know the syntax, but I was wrong, I need to know how the problem works.



---

## Act Like Your Time Is Worth 1000$/hr

      “Busyness” Isn’t a Badge of Honor; It’s a Sign of Weakness
      “Being busy is a form of mental laziness.” -Tim Ferriss
      It takes discipline to not become “busy.”
      If you let it, your world and the people around you will take all your time. Your time is not unlike your paycheck; if you don’t budget for things, you’ll have nothing left over by the end of the month.
      This is how lives are wasted — by doing thankless work for ungrateful takers that didn’t deserve your time in the first place.
      We’re all busy — with work, our families, our friends. It’s not bad to be “busy.” But in the words of best-selling author Jeff Goins:
      “The most successful people I know are not busy. They’re focused.”


      “Being busy is a form of mental laziness.” -Tim Ferriss

      “Busyness and exhaustion should be your enemy. If you’re chronically stressed and up late working, you’re doing something wrong. Do less. But do what you do with complete, hard focus. Then when you’re done be done, and go enjoy the rest of your day.”


      “People are unhappy in large part because they are confused about what is valuable.”

      You Can Do Amazing Things, But Only If You Have Time to Do Them
            
            
      “The difference between successful people and really successful people is that really successful people say no to almost everything.” -Warren Buffet

      “People think focus means saying yes to the thing you’ve got to focus on. But that’s not what it means at all. It means saying no to the hundred other good ideas that there are. You have to pick carefully. I’m actually as proud of the things we haven’t done as the things I have done. Innovation is saying no to 1,000 things.”


  My synopsis: Time is incredibly valuable and putting a price on it is an effective way to change perception on how I view it. I personally don't spend all my time as I should and this article really opened my eyes to how valuable it really is. Especially considering how much I think my time is worth. Great read.


---

## How to Solve Programming Problems

###     A simple set of steps

    I am going to give you a simple set of steps to follow which you can use for any algorithm type programming problem.

1. Read the problem completely twice.
2. Solve the problem manually with 3 sets of sample data.
3. Optimize the manual steps.
4. Write the manual steps as comments or pseudo-code.
5. Replace the comments or pseudo-code with real code.
6. Optimize the real code.
7. As much as 70% of our time should be spent in steps 1-3.

Let’s look at each step.

Read the problem completely twice
This is the single most important step.  You may even want to read the problem 3 or 4 times.

You want to make sure you completely understand the problem.  A good test of this is whether or not you can explain the problem to someone else.

I cannot over-emphasize how important this step is!

If you don’t understand the problem, you cannot solve it.  Do not worry about wasting time here, because the better you understand the problem, the easier it will be to solve it.

If you are given any examples along with the problem, make sure you have worked through the examples and understand why the answers are correct for each one.

Programming is automation plain and simple.  You may have the ability to skip the manual steps and jump directly to code, but there is a manual process which is the foundation of any code you write.

It is very important to solve the problem manually first, so that you know what you are going to automate, otherwise you are just slinging code around.  Which while can be fun, will make you look like an idiot in a programming interview and will probably cause you to sweat profusely.

I recommend that you solve the problem with at least three different inputs to make sure you really understand your solution and that it will work for more than one case.

Optimize the manual solution
People often don’t realize how valuable this step is.  It is much easier to rearrange and reconstruct and idea or algorithm in your head than it is in code.

It’s well worth the effort to try and optimize the actual solution or simplify it when it is still in the most easily malleable state.

What you want to do here is figure out if there is another way you can solve the problem easier, or if there are some steps you can cut our or simplify.

Let’s look at our string reversal example and see if we can simplify the steps.

We should be able to immediately recognize that we can use a loop here to reduce the manual steps.  Our duplicate why’s for most of our steps tell us that we are doing the same thing over and over for each step, just with different data.

Write “Zebra” down.
Start at the last letter in the word and create a new empty word.
Append the current letter to the new word
If there is a previous letter, make the previous letter the current letter and start back at 3.
Look how close we are getting to code at this point.  You should be tempted to actually write the code for this.  That is good, it tells you that you have solved and simplified the problem well.  Writing code should now become very easy.

Write pseudo-code or comments
Many times you can skip this step if you have a really good handle on the problem or your previous steps already created a detailed enough description of the solution that coding it is already a 1 to 1 translation.

If you are a beginner or struggle with these kinds of problems, I would go ahead and take the time to do this step anyway though.

What we want to do here is capture all the steps we created and now either put them into our editor as comments or write them as psuedo-code that we can translate to real code.

By doing this, we can know exactly what the structure of the code we are going to write is going to look like which makes the job of filling in the actual code later trivial.

Let’s look at some psudeo-code for reversing a string.

// NewWord = “”

// Loop backwards through word to reverse

//   NewWord += CurrentLetter

// Return NewWord

Pretty simple, but the key thing we have done here is outlined the structure of the code we will write to solve the problem.

Replace comments with real code
This step should be extremely easy at this point.  If you have done all the other steps, this step involves no problem solving at all.

All we do here is take each comment and convert it into a real line of code.


My synopsis: Programming is all about planning. Don't attack the problem head on. Break down the problem first. Understand the actual problem by reading it as many times as it takes for you to have a complete grasp on the content. Break down the content further by adding comments and then coding from the comments. This process is incredibly smart as it allows you to fully see the entire problem domain instead of putting fingers on the keyboard.

---

# The 5 Why's

When to Use a 5 Whys Analysis
You can use 5 Whys for troubleshooting, quality improvement, and problem solving, but it is most effective when used to resolve simple or moderately difficult problems.

It may not be suitable if you need to tackle a complex or critical problem. This is because 5 Whys can lead you to pursue a single track, or a limited number of tracks, of inquiry when, in fact, there could be multiple causes. In cases like these, a wider-ranging method such as Cause and Effect Analysis  or Failure Mode and Effects Analysis  may be more effective.

This simple technique, however, can often direct you quickly to the root cause of a problem. So, whenever a system or process isn't working properly, give it a try before you embark on a more in-depth approach – and certainly before you attempt to develop a solution.

The tool's simplicity gives it great flexibility, too, and 5 Whys combines well with other methods and techniques, such as Root Cause Analysis . It is often associated with Lean Manufacturing , where it is used to identify and eliminate wasteful practices. It is also used in the analysis phase of the Six Sigma  quality improvement methodology.

How to Use the 5 Whys
The model follows a very simple seven-step process:

1. Assemble a Team
Gather together people who are familiar with the specifics of the problem, and with the process that you're trying to fix. Include someone to act as a facilitator , who can keep the team focused on identifying effective counter-measures.

2. Define the Problem
If you can, observe the problem in action. Discuss it with your team and write a brief, clear problem statement that you all agree on. For example, "Team A isn't meeting its response time targets" or "Software release B resulted in too many rollback failures."

Then, write your statement on a whiteboard or sticky note, leaving enough space around it to add your answers to the repeated question, "Why?"

3. Ask the First "Why?"
Ask your team why the problem is occurring. (For example, "Why isn't Team A meeting its response time targets?")

Asking "Why?" sounds simple, but answering it requires serious thought. Search for answers that are grounded in fact: they must be accounts of things that have actually happened, not guesses at what might have happened.

This prevents 5 Whys from becoming just a process of deductive reasoning, which can generate a large number of possible causes and, sometimes, create more confusion as you chase down hypothetical problems.

Your team members may come up with one obvious reason why, or several plausible ones. Record their answers as succinct phrases, rather than as single words or lengthy statements, and write them below (or beside) your problem statement. For example, saying "volume of calls is too high" is better than a vague "overloaded."

4. Ask "Why?" Four More Times
For each of the answers that you generated in Step 3, ask four further "whys" in succession. Each time, frame the question in response to the answer you've just recorded.

Tip:
Try to move quickly from one question to the next, so that you have the full picture before you jump to any conclusion

5. Know When to Stop
You'll know that you've revealed the root cause of the problem when asking "why" produces no more useful responses, and you can go no further. An appropriate counter-measure or process change should then become evident. (As we said earlier, if you're not sure that you've uncovered the real root cause, consider using a more in-depth problem-solving technique like Cause and Effect Analysis , Root Cause Analysis , or FMEA .)

If you identified more than one reason in Step 3, repeat this process for each of the different branches of your analysis until you reach a root cause for each one.


My synopsis: Five why's is a great way to get to the root issue of a problem. Asking questions is beneficial because it grants information not previously known. Without diving into multiple questions it is impossible to get to the root cause of the issue. I especially liked bringing in your team to get to the heart of the problem. This resonated with me because the process of programming is basically a hive mind. Information is passed around regularly and it's what allows this field to grow and flourish. If it weren't, people wouldn't be getting paid upwards of 300k a year just to get their answers from StackOverflow.